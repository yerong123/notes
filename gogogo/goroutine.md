# goroutine

goroutine是go在语言级别支持并发的一种特性。

来个简单易懂的:D， 比如：

	go func(){ 
		 fmt.println("晚上吃炸鸡排呀？") 
	}
	
go是关键字，后面跟着的方法会单独启一个线程（其实是协程）来执行。帅吗帅吗帅吗


## 概念

### 进程

- 有自己独立的堆和栈，不跟其他进程共享
- 由操作系统调度


### 线程

- 有独立的栈，与其他线程共享堆
- 标准的线程由操作系统来调度

### 协程

- 独立的栈，共享堆
- 程序员在代码里显示的调度

进程与线程和协程的区别还是很明显的。主要看线程和协程的区别。

- 线程：具备使用多cpu的能力；由操作系统调度
- 协程：不具备使用多cup的能力；由程序员在代码中调度

协程的优点：由程序员调度，比较灵活，避免了无意义的调度，提高性能。

协程的缺点：没有使用多cpu的能力；程序员要承担调度的责任。

### 协程和线程哪个性能好？

假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 * 0.1 = 21.9 秒。如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 * 0.1 = 20.1 秒。如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。

### 简单的说，线程跑在cpu核上，协程跑在线程上；线程共享一个核时，轮换执行（假装并行），协程共享一个线程时，顺序执行（goroutine不是顺序的哦~）。

## goroutine

**Go程序中没有语言级的关键字让你去创建一个内核线程（标准线程），你只能创建goroutine，内核线程（标准线程）只能由runtime根据实际情况去创建。goroutine属于协程（非标准线程，用户级线程），由程序员调度，不具备使用多cpu的能力。**

# 重点来了
M==线程；G==goroutine；P==processor；Sched==调度器

- M、G、P的关系：M和P绑定，来执行G

- sched和P的关系：P存在sched中

- sched和M、G的关系：sched调度M和G


P维护一个线程上的n个协程G，G不是顺序执行的，而是像线程一样轮换执行的，P来暂停或启动一个goroutine

> 关于效率：每个M都有一个g0栈内存，用来执行运行时管理命令。调度时候M的g0会从每个G栈取出栈(现场)，调度之后再保存到G，这样不同的M就可以接着调度了。所有上下文都是自己在切换，省去了内核带来的开销，而且Golang会观察，长时间不调度的G会被其他G抢占(抢占调度其实就是一个标记)。

线程上没有goroutine了，P去调度器全局等待队列中去取长期没被调度的G，如果没有，则会去别的线程上偷goroutine来执行。如果有没有，线程就sleep了。

**程序启动时，系统会创建一堆P（最多是256个）。在程序执行过程中，系统根据需求去创建M。M与P绑定才能执行G，所以M最多==P的个数**

**可以通过go的max_proc来配置当前应用使用的cpu内核数，程序启动时根据配置的cpu核数去创建P**







